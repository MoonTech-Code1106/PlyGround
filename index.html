<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="icon" href="Logo.png" type="image/png">
<title>PlyGround Physics Engine</title>
<style>
  html {cursor: url('pointer.png'), auto; }
  body { margin:0; overflow:hidden; background:#0d1117; color:white; font-family:"Segoe UI",sans-serif; }
  .navbar { display:flex; align-items:center; justify-content:space-between; background:linear-gradient(90deg,#00ff95,#0077ff); padding:10px 20px; }
  .navbar-left { display:flex; align-items:center; }
  .navbar img { height:40px; margin-right:10px; }
  .navbar h1 { font-size:22px; margin:0; }
  .delete-menu { display:flex; gap:10px; }
  .delete-menu button { background:#111; color:white; border:1px solid #00ff95; border-radius:6px; padding:5px 10px; cursor:pointer; transition:0.2s; }
  .delete-menu button:hover { background:#00ff95; color:black; }
  canvas { display:block; background:#161b22; }
</style>
</head>
<body>

<div class="navbar">
  <div class="navbar-left">
    <img src="Logo.png" alt="Logo">
    <h1>PlyGround Physics Engine</h1>
  </div>
  <div class="delete-menu">
    <button id="delLast">Delete Last</button>
    <button id="delAll">Delete All</button>
    <button id="delMode">Delete Mode: OFF</button>
  </div>
</div>

<canvas id="world"></canvas>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
const { Engine, Render, Runner, Bodies, World, Mouse, MouseConstraint, Events, Body, Vector } = Matter;

// --- Setup ---
const engine = Engine.create();
const world = engine.world;
const canvas = document.getElementById("world");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 60;

const render = Render.create({
  canvas,
  engine,
  options: {
    width: canvas.width,
    height: canvas.height,
    background: "#161b22",
    wireframes: false,
  },
});
Render.run(render);
Runner.run(Runner.create(), engine);

// --- Boundaries ---
const ground = Bodies.rectangle(canvas.width/2, canvas.height, canvas.width, 60, { isStatic: true, label: "Ground" });
const leftWall = Bodies.rectangle(0, canvas.height/2, 60, canvas.height, { isStatic: true, label: "Wall" });
const rightWall = Bodies.rectangle(canvas.width, canvas.height/2, 60, canvas.height, { isStatic: true, label: "Wall" });
World.add(world, [ground, leftWall, rightWall]);

// --- Track spawned bodies ---
let spawnedBodies = [];

// --- Spawn Functions (labels added) ---
function spawnBall(x, y) {
  const ball = Bodies.circle(x, y, 30, { restitution: 0.9, friction: 0.01, render: { fillStyle: "#00ccff" }, label: "Ball" });
  World.add(world, ball);
  spawnedBodies.push(ball);
}
function spawnBox(x, y) {
  const box = Bodies.rectangle(x, y, 60, 60, {
    restitution: 0.9,
    friction: 0.02,
    render: {
      sprite: {
        texture: "Box.png",  
        xScale: 0.15,               
        yScale: 0.15
      }
    },
    label: "Box"
  });
  World.add(world, box);
  spawnedBodies.push(box);
}
function spawnTriangle(x, y) {
  const tri = Bodies.polygon(x, y, 3, 50, { restitution: 0.9, render: { fillStyle: "#ff6699" }, label: "Triangle" });
  World.add(world, tri);
  spawnedBodies.push(tri);
}
function spawnRod(x, y) {
  const rod = Bodies.rectangle(x, y, 300, 35, { restitution: 0.9, friction: 0.02, density: 0.004, render: { fillStyle: "#88ff88" }, label: "Rod" });
  World.add(world, rod);
  spawnedBodies.push(rod);
}
function spawnStar(x, y) {
  const star = Bodies.polygon(x, y, 5, 40, { restitution: 0.8, render: { fillStyle: "#ff33cc" }, label: "Star" });
  World.add(world, star);
  spawnedBodies.push(star);
}
function spawnHex(x, y) {
  const hex = Bodies.polygon(x, y, 6, 50, { restitution: 0.8, render: { fillStyle: "#33ffcc" }, label: "Hex" });
  World.add(world, hex);
  spawnedBodies.push(hex);
}
function spawnPlank(x, y) {
  const plank = Bodies.rectangle(x, y, 400, 20, { restitution: 0.6, render: { fillStyle: "#ffaa33" }, label: "Plank" });
  World.add(world, plank);
  spawnedBodies.push(plank);
}
function spawnMiniBall(x, y) {
  const small = Bodies.circle(x, y, 15, { restitution: 1.0, friction: 0, render: { fillStyle: "#ffffff" }, label: "MiniBall" });
  World.add(world, small);
  spawnedBodies.push(small);
}
// --- Mouse Control ---
const mouse = Mouse.create(render.canvas);
const mouseConstraint = MouseConstraint.create(engine, { mouse, constraint: { stiffness: 0.2, render: { visible: false } } });
World.add(world, mouseConstraint);
render.mouse = mouse;

let dragStart = null;
let dragBody = null;
Events.on(mouseConstraint, "startdrag", e => { dragBody = e.body; dragStart = { ...mouse.position }; });
Events.on(mouseConstraint, "enddrag", e => {
  if (dragBody) {
    const dragEnd = { ...mouse.position };
    const dir = Vector.sub(dragEnd, dragStart);
    const distance = Vector.magnitude(dir);
    if (distance > 10) {
      const normalized = Vector.normalise(dir);
      const power = Math.min(distance * 0.0004, 0.02);
      const force = Vector.mult(normalized, power);
      Body.applyForce(dragBody, dragBody.position, force);
    }
  }
  dragBody = null;
  dragStart = null;
});

// --- Spawn Hotkeys ---
document.addEventListener("keydown", e => {
  const k = e.key.toLowerCase();
  if (k === "1") spawnBall(mouse.position.x, mouse.position.y);
  if (k === "2") spawnBox(mouse.position.x, mouse.position.y);
  if (k === "3") spawnTriangle(mouse.position.x, mouse.position.y);
  if (k === "4") spawnRod(mouse.position.x, mouse.position.y);
  if (k === "5") spawnStar(mouse.position.x, mouse.position.y);
  if (k === "6") spawnHex(mouse.position.x, mouse.position.y);
  if (k === "7") spawnPlank(mouse.position.x, mouse.position.y);
  if (k === "8") spawnMiniBall(mouse.position.x, mouse.position.y);
});

// --- Delete Menu ---
const delLastBtn = document.getElementById("delLast");
const delAllBtn = document.getElementById("delAll");
const delModeBtn = document.getElementById("delMode");
let deleteMode = false;
delLastBtn.onclick = () => { const last = spawnedBodies.pop(); if (last) World.remove(world, last); };
delAllBtn.onclick = () => window.location.reload();
delModeBtn.onclick = () => { deleteMode = !deleteMode; delModeBtn.textContent = `Delete Mode: ${deleteMode ? "ON" : "OFF"}`; };
Events.on(mouseConstraint, "mousedown", e => {
  if (deleteMode && e.body && !e.body.isStatic) {
    World.remove(world, e.body);
    spawnedBodies = spawnedBodies.filter(b => b !== e.body);
  }
});

// --- ðŸ”¥ FIRE SYSTEM (with soft glow) ---
const fires = [];
const burningBodies = new Set();

function createFireCluster(x, y, sizeFactor = 1) {
  for (let i = 0; i < 8; i++) {
    fires.push({
      x: x + (Math.random() - 0.5) * 40,
      y: y + (Math.random() - 0.5) * 40,
      size: (Math.random() * 10 + 15) * sizeFactor,
      life: 1,
      rise: 1.8 + Math.random() * 1.8,
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.25,
    });
  }
}

(function animateFire() {
  requestAnimationFrame(animateFire);
  const ctx = render.context;
  if (!ctx) return;
  ctx.save();
  ctx.globalCompositeOperation = "lighter";

  for (let i = fires.length - 1; i >= 0; i--) {
    const f = fires[i];
    f.y -= f.rise;
    f.rotation += f.rotSpeed;
    f.life -= 0.014;
    const alpha = Math.max(f.life, 0);

    // --- ðŸŸ  Draw flame particle ---
    const grad = ctx.createLinearGradient(f.x, f.y + f.size, f.x, f.y - f.size);
    grad.addColorStop(0, "rgba(255,0,0,0.9)");
    grad.addColorStop(1, "rgba(125,125,0,0.1)");
    ctx.translate(f.x, f.y);
    ctx.rotate(f.rotation);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = grad;
    ctx.fillRect(-f.size / 2, -f.size / 2, f.size, f.size);
    ctx.setTransform(1, 0, 0, 1, 0, 0);

  }

  ctx.restore();
})();
// Track mouse position
let mouseX = 0, mouseY = 0;

window.addEventListener("mousemove", (e) => {
  const rect = render.canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
});

// Listen for 'S' key press
window.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === 's') {
    createFireCluster(mouseX, mouseY, 1); // sizeFactor = 1
  }
});


// --- IGNITE & ASH SYSTEM ---
function igniteNearbyBodies() {
  for (const body of spawnedBodies) {
    if (body.isStatic || !body.position) continue;
    if (burningBodies.has(body)) continue;
    if (body.label !== "Box" && body.label !== "Plank") continue;

    for (const fire of fires) {
      const dx = fire.x - body.position.x;
      const dy = fire.y - body.position.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 60) igniteBody(body);
    }
  }
}
setInterval(igniteNearbyBodies, 100);

function igniteBody(body) {
  if (burningBodies.has(body)) return;
  burningBodies.add(body);

  const burnInterval = setInterval(() => {
    if (!spawnedBodies.includes(body)) {
      clearInterval(burnInterval);
      burningBodies.delete(body);
      return;
    }
    createFireCluster(body.position.x, body.position.y - 30, 0.8);
  }, 200);

  setTimeout(() => {
    clearInterval(burnInterval);
    burningBodies.delete(body);
    turnToAsh(body);
  }, 10000);
}

function turnToAsh(body) {
  if (!spawnedBodies.includes(body)) return;

  const width = body.bounds.max.x - body.bounds.min.x;
  const height = body.bounds.max.y - body.bounds.min.y;

  const ash = Bodies.rectangle(
    body.position.x,
    body.position.y,
    width,
    height,
    {
      restitution: 0.2,
      friction: 0.8,
      density: 0.0005,
      label: "Ash",
      render: {
        sprite: {
          texture: "Ash.png",  // ðŸ’€ your ash texture file
          xScale: width / 512,         // adjust depending on texture resolution
          yScale: height / 512
        }
      }
    }
  );

  World.remove(world, body);
  World.add(world, ash);
  spawnedBodies = spawnedBodies.filter(b => b !== body);
  spawnedBodies.push(ash);
}

Events.on(engine, "collisionStart", e => {
  for (const pair of e.pairs) {
    [pair.bodyA, pair.bodyB].forEach(b => {
      if (b.label === "Ash" && pair.collision.depth > 5) crumbleAsh(b);
    });
  }
});

function crumbleAsh(ash) {
  if (!spawnedBodies.includes(ash)) return;
  const x = ash.position.x, y = ash.position.y;
  World.remove(world, ash);
  spawnedBodies = spawnedBodies.filter(b => b !== ash);

  for (let i = 0; i < 8; i++) {
    const size = 8 + Math.random() * 4;
    const frag = Bodies.rectangle(
      x + (Math.random() - 0.5) * 40,
      y + (Math.random() - 0.5) * 20,
      size,
      size,
      {
        restitution: 0.6,
        friction: 0.9,
        density: 0.0003,
        render: {
          fillStyle: "#555",
          opacity: 1, // start fully visible
        },
        label: "AshFragment",
      }
    );

    // Apply a random flying force
    const forceMagnitude = 0.0005 + Math.random() * 0.0001;
    const angle = Math.random() * Math.PI * 2; // random direction
    Body.applyForce(frag, frag.position, {
      x: Math.cos(angle) * forceMagnitude,
      y: Math.sin(angle) * forceMagnitude,
    });

    World.add(world, frag);
    spawnedBodies.push(frag);

    // Gradually fade out and remove after 10s
    const fadeDuration = 10000; // 10 seconds
    const fadeStep = 100; // update every 0.1s
    let elapsed = 0;

    const fadeInterval = setInterval(() => {
      elapsed += fadeStep;
      const alpha = Math.max(1 - elapsed / fadeDuration, 0);
      frag.render.opacity = alpha;

      if (alpha <= 0) {
        clearInterval(fadeInterval);
        World.remove(world, frag);
        spawnedBodies = spawnedBodies.filter(b => b !== frag);
      }
    }, fadeStep);
  }
}


// --- ðŸ”¦ TORCH SYSTEM (Dynamic, Textured Torch with Moving Flame) ---
const torches = [];

function spawnTorch(x, y) {
  const torch = Bodies.rectangle(x, y, 20, 120, {
    restitution: 0.3,
    friction: 0.6,
    density: 0.002,
    render: {
      sprite: {
        texture: "torch.png", // ðŸªµ Your torch image file
        xScale: 0.25,          // adjust these two if needed
        yScale: 0.25,
      },
    },
    label: "Torch",
  });

  World.add(world, torch);
  spawnedBodies.push(torch);
  torches.push(torch);
  


  // ðŸ”¥ Fire that follows the top dynamically
  const fireInterval = setInterval(() => {
    if (!spawnedBodies.includes(torch)) {
      clearInterval(fireInterval);
      return;
    }

    // Dynamic top position using rotation
    const topOffset = Vector.rotate({ x: 0, y: -60 }, torch.angle);
    const topX = torch.position.x + topOffset.x;
    const topY = torch.position.y + topOffset.y;

    createFireCluster(topX, topY, 1.2);
  }, 250);
}

// ðŸ•¯ï¸ Press "T" to spawn torch
document.addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "t") {
    const { x, y } = mouse.position;
    spawnTorch(x, y);
  }
});
// --- TNT ARRAY ---
let spawnedTNTs = [];

// --- SPAWN TNT (Press T) ---
document.addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "x") {
    const tnt = Bodies.rectangle(mouse.position.x, mouse.position.y, 45, 45, {
      label: "TNT",
      restitution: 0.4,
      friction: 0.6,
      render: {
        fillStyle: "#cc0000",
        strokeStyle: "#ffffff",
        lineWidth: 2
      }
    });
    World.add(world, tnt);
    spawnedBodies.push(tnt);
    spawnedTNTs.push(tnt);
  }
});

// --- IGNITE TNT (Press E) ---
document.addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "e") {
    if (spawnedTNTs.length === 0) return;

    const nearestTNT = spawnedTNTs[spawnedTNTs.length - 1];

    // ðŸ”¥ Visual fuse flame
    createFireCluster(nearestTNT.position.x, nearestTNT.position.y, 1.4);

    // ðŸ§¨ Text hint
    const ctx = render.context;
    ctx.font = "bold 18px Arial";
    ctx.fillStyle = "white";
    ctx.fillText("ðŸ’¥ FUSE LIT! GET BACK!", nearestTNT.position.x - 60, nearestTNT.position.y - 60);

    // Delay for fuse (2.5s)
    setTimeout(() => explodeTNT(nearestTNT), 2500);
  }
});


// --- EXPLOSION FUNCTION ---
function explodeTNT(tnt) {
  const x = tnt.position.x;
  const y = tnt.position.y;
  const radius = 300; // Bigger blast radius

  // ðŸ’¥ Stronger visual shockwave
  for (let i = 0; i < 25; i++) {
    createFireCluster(x, y, 1.8);
  }

  // ðŸ”Š Add visible expanding ring (shockwave)
  let waveLife = 1;
  const wave = { x, y, r: 0, life: waveLife };
  const ctx = render.context;

  function animateWave() {
    if (wave.life <= 0) return;
    requestAnimationFrame(animateWave);
    wave.r += 25; // expand speed
    wave.life -= 0.03;

    ctx.save();
    ctx.beginPath();
    ctx.arc(wave.x, wave.y, wave.r, 0, 2 * Math.PI);
    ctx.lineWidth = 6;
    ctx.strokeStyle = `rgba(255,255,255,${wave.life})`;
    ctx.stroke();
    ctx.restore();
  }
  animateWave();

  // ðŸ’¨ Apply much stronger blast force
  for (const body of spawnedBodies) {
    if (body === tnt) continue;
    const dx = body.position.x - x;
    const dy = body.position.y - y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < radius) {
      // Stronger and more consistent push
      const forceMag = Math.max(0, 0.55 * (1 - dist / radius)); 
      const angle = Math.atan2(dy, dx);
      const force = {
        x: Math.cos(angle) * forceMag,
        y: Math.sin(angle) * forceMag - 0.02 // adds upward lift
      };
      Body.applyForce(body, body.position, force);
    }
  }


  // ðŸ”¥ Ignite nearby boxes/planks only
  for (const body of spawnedBodies) {
    const dx = body.position.x - x;
    const dy = body.position.y - y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 220 && (body.label === "Box" || body.label === "Plank")) {
      igniteBody(body);
    }
  }

  // ðŸ§¨ Remove TNT body
  World.remove(world, tnt);
  spawnedBodies = spawnedBodies.filter(b => b !== tnt);
  spawnedTNTs = spawnedTNTs.filter(b => b !== tnt);
}
// --- ðŸª¢ Real Rope Physics (auto-breaks, no shake) ---
const { Constraint, Query } = Matter;
let ropeMode = false;
let ropeStart = null;
let ropes = [];
let highlightBody = null;

document.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();

  if (key === "q") {
    ropeMode = !ropeMode;
    ropeStart = null;
    highlightBody = null;
    console.log(`ðŸª¢ Rope Mode: ${ropeMode ? "ON" : "OFF"}`);
  }

  // ðŸ—‘ Remove nearest rope
  if (key === "r") {
    if (ropes.length > 0) {
      const mousePos = mouse.position;
      let nearestRope = null;
      let nearestDist = Infinity;

      for (const rope of ropes) {
        for (const seg of rope.segments) {
          const dx = seg.position.x - mousePos.x;
          const dy = seg.position.y - mousePos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestRope = rope;
          }
        }
      }

      if (nearestRope && nearestDist < 100) removeRope(nearestRope);
      else removeRope(ropes[ropes.length - 1]);
      console.log("âŒ Rope removed.");
    }
  }
});

function removeRope(rope) {
  for (const seg of rope.segments) World.remove(world, seg);
  for (const c of rope.constraints) World.remove(world, c);
  ropes = ropes.filter(r => r !== rope);
}

// --- Rope creation ---
Events.on(mouseConstraint, "mousedown", () => {
  if (!ropeMode) return;
  const mousePos = mouse.position;
  const found = Query.point(spawnedBodies, mousePos);
  if (found.length > 0) {
    const body = found[0];
    if (!ropeStart) {
      ropeStart = body;
      console.log("ðŸ”¹ First body selected for rope.");
    } else if (body !== ropeStart) {
      createRealRope(ropeStart, body);
      ropeStart = null;
      console.log("ðŸª¢ Rope created.");
    }
  }
});

// --- Highlight body under mouse ---
Events.on(render, "beforeRender", () => {
  if (!ropeMode) {
    highlightBody = null;
    return;
  }
  const found = Query.point(spawnedBodies, mouse.position);
  highlightBody = found.length > 0 ? found[0] : null;
});

// --- Create Realistic Rope ---
function createRealRope(bodyA, bodyB, segments = 12) {
  const ropeSegments = [];
  const constraints = [];

  const start = bodyA.position;
  const end = bodyB.position;
  const dx = (end.x - start.x) / (segments + 1);
  const dy = (end.y - start.y) / (segments + 1);
  const segmentLength = Math.sqrt(dx * dx + dy * dy);

  // Create rope links
  for (let i = 0; i < segments; i++) {
    const link = Bodies.circle(start.x + dx * (i + 1), start.y + dy * (i + 1), 3, {
      friction: 0.4,
      restitution: 0,
      mass: 0.1,
      density: 0.002,
      collisionFilter: { group: -1 },
      render: { fillStyle: "#ffaa00" }
    });
    ropeSegments.push(link);
    World.add(world, link);
  }

  // Add constraints (with adaptive stiffness to reduce shaking)
  constraints.push(Constraint.create({
    bodyA: bodyA,
    bodyB: ropeSegments[0],
    length: segmentLength,
    stiffness: 0.3
  }));

  for (let i = 0; i < ropeSegments.length - 1; i++) {
    constraints.push(Constraint.create({
      bodyA: ropeSegments[i],
      bodyB: ropeSegments[i + 1],
      length: segmentLength,
      stiffness: 0.3
    }));
  }

  constraints.push(Constraint.create({
    bodyA: ropeSegments[ropeSegments.length - 1],
    bodyB: bodyB,
    length: segmentLength,
    stiffness: 0.3
  }));

  for (const c of constraints) World.add(world, c);

  ropes.push({ bodyA, bodyB, segments: ropeSegments, constraints });
}

// --- Rope Auto-Break System ---
Events.on(engine, "afterUpdate", () => {
  for (let i = ropes.length - 1; i >= 0; i--) {
    const rope = ropes[i];
    // if any body no longer exists â†’ break rope
    if (!world.bodies.includes(rope.bodyA) || !world.bodies.includes(rope.bodyB)) {
      removeRope(rope);
      console.log("ðŸ’¥ Rope broke: connected body removed.");
    }
  }
});

// --- Render rope + highlight ---
Events.on(render, "afterRender", () => {
  const ctx = render.context;
  ctx.save();
  ctx.strokeStyle = "#ffaa00";
  ctx.lineWidth = 3;
  ctx.shadowColor = "#ffaa00";
  ctx.shadowBlur = 6;

  for (const rope of ropes) {
    const pts = rope.segments.map(seg => seg.position);
    if (pts.length < 2) continue;
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();
  }

  // Highlight body when in rope mode
  if (highlightBody) {
    const b = highlightBody.bounds;
    ctx.strokeStyle = ropeStart ? "#00ffff" : "#00ff00";
    ctx.lineWidth = 2;
    ctx.shadowBlur = 8;
    ctx.shadowColor = ctx.strokeStyle;
    ctx.strokeRect(b.min.x - 2, b.min.y - 2, b.max.x - b.min.x + 4, b.max.y - b.min.y + 4);
  }

  ctx.restore();
});


// --- ðŸ”© SCREW SYSTEM (With Texture + Removal) ---
let screwMode = false;
let screws = []; // store screws with linked bodies

document.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();

  // Toggle screw mode
  if (key === "z") {
    screwMode = !screwMode;
    console.log(`ðŸ”© Screw Mode: ${screwMode ? "ON" : "OFF"}`);

    // When pressing Z while dragging a body
    if (screwMode && mouseConstraint.body && !mouseConstraint.body.isStatic) {
      const target = mouseConstraint.body;
      const pos = { x: mouse.position.x, y: mouse.position.y };

      // Create screw visual
      const screw = Bodies.circle(pos.x, pos.y, 15, {
        isStatic: true,
        render: {
          sprite: {
            texture: "Screw.png", // ðŸ§· your screw texture file
            xScale: 0.1,
            yScale: 0.1,
          }
        },
        label: "Screw"
      });
      World.add(world, screw);

      // Turn body static
      Body.setStatic(target, true);
      console.log("ðŸ§± Object screwed and fixed in place.");

      screws.push({ screw, target });
      screwMode = false; // auto turn off mode after placing
    }
  }

  // Remove screw (press R)
  if (key === "c") {
    const mousePos = mouse.position;
    for (let i = screws.length - 1; i >= 0; i--) {
      const { screw, target } = screws[i];
      const dx = mousePos.x - screw.position.x;
      const dy = mousePos.y - screw.position.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // If mouse near screw, unscrew it
      if (dist < 40) {
        World.remove(world, screw);
        Body.setStatic(target, false);
        console.log("ðŸ”“ Screw removed â€” object is now dynamic again!");
        screws.splice(i, 1);

        // ðŸ”„ Small unscrew animation effect
        const ctx = render.context;
        ctx.save();
        ctx.strokeStyle = "#ffcc00";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(mousePos.x, mousePos.y, 20, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.restore();
      }
    }
  }
});

// Optional visual marker glow (so you can see all screws)
Events.on(render, "afterRender", () => {
  const ctx = render.context;
  ctx.save();
  for (const { screw } of screws) {
    ctx.beginPath();
    ctx.arc(screw.position.x, screw.position.y, 16, 0, 2 * Math.PI);
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,255,0,0.4)";
    ctx.stroke();
  }
  ctx.restore();
});

</script>
