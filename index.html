<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PlyGround Physics Engine</title>
<!-- redeploy test -->

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #0d1117;
    color: white;
    font-family: "Segoe UI", sans-serif;
  }

  .navbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: linear-gradient(90deg, #00ff95, #0077ff);
    padding: 10px 20px;
  }

  .navbar-left {
    display: flex;
    align-items: center;
  }

  .navbar img {
    height: 40px;
    margin-right: 10px;
  }

  .navbar h1 {
    font-size: 22px;
    margin: 0;
  }

  .delete-menu {
    display: flex;
    gap: 10px;
  }

  .delete-menu button {
    background: #111;
    color: white;
    border: 1px solid #00ff95;
    border-radius: 6px;
    padding: 5px 10px;
    cursor: pointer;
    transition: 0.2s;
  }

  .delete-menu button:hover {
    background: #00ff95;
    color: black;
  }

  canvas {
    display: block;
    background: #161b22;
  }
</style>
</head>
<body>

<div class="navbar">
  <div class="navbar-left">
    <img src="Logo.png" alt="Logo">
    <h1>PlyGround Physics Engine</h1>
  </div>

  <div class="delete-menu">
    <button id="delLast">Delete Last</button>
    <button id="delAll">Delete All</button>
    <button id="delMode">Delete Mode: OFF</button>
  </div>
</div>

<canvas id="world"></canvas>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
const { Engine, Render, Runner, Bodies, World, Mouse, MouseConstraint, Events, Body, Vector } = Matter;

// --- Setup ---
const engine = Engine.create();
const world = engine.world;
const canvas = document.getElementById("world");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 60;

const render = Render.create({
  canvas,
  engine,
  options: {
    width: canvas.width,
    height: canvas.height,
    background: "#161b22",
    wireframes: false,
  },
});

Render.run(render);
Runner.run(Runner.create(), engine);

// --- Boundaries ---
const ground = Bodies.rectangle(canvas.width/2, canvas.height, canvas.width, 60, { isStatic: true });
const leftWall = Bodies.rectangle(0, canvas.height/2, 60, canvas.height, { isStatic: true });
const rightWall = Bodies.rectangle(canvas.width, canvas.height/2, 60, canvas.height, { isStatic: true });
World.add(world, [ground, leftWall, rightWall]);

// --- Track spawned bodies ---
let spawnedBodies = [];

// --- Spawn Functions ---
function spawnBall(x, y) {
  const ball = Bodies.circle(x, y, 30, { restitution: 0.9, friction: 0.01, render: { fillStyle: "#00ccff" } });
  World.add(world, ball);
  spawnedBodies.push(ball);
}

function spawnBox(x, y) {
  const box = Bodies.rectangle(x, y, 60, 60, { restitution: 0.9, friction: 0.02, render: { fillStyle: "#ffcc00" } });
  World.add(world, box);
  spawnedBodies.push(box);
}

function spawnTriangle(x, y) {
  const tri = Bodies.polygon(x, y, 3, 50, { restitution: 0.9, render: { fillStyle: "#ff6699" } });
  World.add(world, tri);
  spawnedBodies.push(tri);
}

function spawnRod(x, y) {
  const rod = Bodies.rectangle(x, y, 300, 35, { restitution: 0.9, friction: 0.02, density: 0.004, render: { fillStyle: "#88ff88" } });
  World.add(world, rod);
  spawnedBodies.push(rod);
}

function spawnStar(x, y) {
  const star = Bodies.polygon(x, y, 5, 40, { restitution: 0.8, render: { fillStyle: "#ff33cc" } });
  World.add(world, star);
  spawnedBodies.push(star);
}

function spawnHex(x, y) {
  const hex = Bodies.polygon(x, y, 6, 50, { restitution: 0.8, render: { fillStyle: "#33ffcc" } });
  World.add(world, hex);
  spawnedBodies.push(hex);
}

function spawnPlank(x, y) {
  const plank = Bodies.rectangle(x, y, 400, 20, { restitution: 0.6, render: { fillStyle: "#ffaa33" } });
  World.add(world, plank);
  spawnedBodies.push(plank);
}

function spawnMiniBall(x, y) {
  const small = Bodies.circle(x, y, 15, { restitution: 1.0, friction: 0, render: { fillStyle: "#ffffff" } });
  World.add(world, small);
  spawnedBodies.push(small);
}

function spawnHeavyBlock(x, y) {
  const heavy = Bodies.rectangle(x, y, 100, 100, { restitution: 0.1, density: 0.02, render: { fillStyle: "#7777ff" } });
  World.add(world, heavy);
  spawnedBodies.push(heavy);
}

// --- Mouse Control ---
const mouse = Mouse.create(render.canvas);
const mouseConstraint = MouseConstraint.create(engine, {
  mouse,
  constraint: { stiffness: 0.2, render: { visible: false } }
});
World.add(world, mouseConstraint);
render.mouse = mouse;

// --- Throw Mechanics ---
let dragStart = null;
let dragBody = null;

Events.on(mouseConstraint, "startdrag", e => {
  dragBody = e.body;
  dragStart = { ...mouse.position };
});

Events.on(mouseConstraint, "enddrag", e => {
  if (dragBody) {
    const dragEnd = { ...mouse.position };
    const dir = Vector.sub(dragEnd, dragStart);
    const distance = Vector.magnitude(dir);

    if (distance > 10) {
      const normalized = Vector.normalise(dir);
      const power = Math.min(distance * 0.0004, 0.02);
      const force = Vector.mult(normalized, power);
      Body.applyForce(dragBody, dragBody.position, force);
    }
  }
  dragBody = null;
  dragStart = null;
});

// --- Spawn Hotkeys ---
document.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  if (key === "1") spawnBall(mouse.position.x, mouse.position.y);
  if (key === "2") spawnBox(mouse.position.x, mouse.position.y);
  if (key === "3") spawnTriangle(mouse.position.x, mouse.position.y);
  if (key === "4") spawnRod(mouse.position.x, mouse.position.y);
  if (key === "5") spawnStar(mouse.position.x, mouse.position.y);
  if (key === "6") spawnHex(mouse.position.x, mouse.position.y);
  if (key === "7") spawnPlank(mouse.position.x, mouse.position.y);
  if (key === "8") spawnMiniBall(mouse.position.x, mouse.position.y);
  if (key === "9") spawnHeavyBlock(mouse.position.x, mouse.position.y);
});

// --- Delete Menu ---
const delLastBtn = document.getElementById("delLast");
const delAllBtn = document.getElementById("delAll");
const delModeBtn = document.getElementById("delMode");
let deleteMode = false;

delLastBtn.onclick = () => {
  const last = spawnedBodies.pop();
  if (last) World.remove(world, last);
};

delAllBtn.onclick = () => {
  spawnedBodies.forEach(b => World.remove(world, b));
  spawnedBodies = [];
};

delModeBtn.onclick = () => {
  deleteMode = !deleteMode;
  delModeBtn.textContent = `Delete Mode: ${deleteMode ? "ON" : "OFF"}`;
};

// --- Delete on click ---
Events.on(mouseConstraint, "mousedown", e => {
  if (deleteMode && e.body && !e.body.isStatic) {
    World.remove(world, e.body);
    spawnedBodies = spawnedBodies.filter(b => b !== e.body);
  }
});
// --- Spacebar Explosion + Delayed Shockwave ---
document.addEventListener("keydown", e => {
  if (e.code === "Space") {
    const x = mouse.position.x;
    const y = mouse.position.y;

    // ðŸ’£ Spawn explosive cube (TNT)
    const bomb = Bodies.rectangle(x, y, 50, 50, {
      restitution: 0.8,
      frictionAir: 0.02,
      render: { fillStyle: "#ff3333" }
    });
    World.add(world, bomb);
    spawnedBodies.push(bomb);

    // ðŸ’¥ Wait, then detonate at TNT's actual position
    setTimeout(() => {
      const bx = bomb.position.x;
      const by = bomb.position.y;

      const blastRadius = 300;
      let blastPower = 0.45;

      spawnedBodies.forEach(body => {
        if (body !== bomb && !body.isStatic) {
          const dir = Vector.sub(body.position, { x: bx, y: by });
          const dist = Vector.magnitude(dir);

          if (dist < blastRadius) {
            const normalized = Vector.normalise(dir);
            const falloff = 1 - dist / blastRadius;
            const force = Vector.mult(normalized, blastPower * falloff);
            Body.applyForce(body, body.position, force);
          }
        }
      });

      // ðŸ’£ Remove bomb after blast
      World.remove(world, bomb);
      spawnedBodies = spawnedBodies.filter(b => b !== bomb);

      // ðŸŒŠ Create shockwave AFTER explosion
      setTimeout(() => {
        const ring = {
          x: bx,
          y: by,
          radius: 0,
          opacity: 1
        };
        shockwaves.push(ring);
      }, 200); // delay for realistic timing

    }, 800); // detonation delay
  }
});

// ðŸŒ€ Animate shockwave rings
const shockwaves = [];

(function animateShockwaves() {
  requestAnimationFrame(animateShockwaves);
  const ctx = render.context;

  shockwaves.forEach((r, i) => {
    r.radius += 6; // expansion speed
    r.opacity -= 0.02; // fade out speed

    if (r.opacity <= 0) {
      shockwaves.splice(i, 1);
      return;
    }

    ctx.beginPath();
    ctx.arc(r.x, r.y, r.radius, 0, 2 * Math.PI);
    ctx.strokeStyle = `rgba(255, 170, 0, ${r.opacity})`; // glowing orange
    ctx.lineWidth = 5;
    ctx.stroke();
  });
})();

</script>
</body>
</html>
