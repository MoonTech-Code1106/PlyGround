<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="icon" href="Logo.png" type="image/png">
<title>PlyGround Physics Engine</title>
<style>
  html {cursor: url('pointer.png'), auto; }
  body { margin:0; overflow:hidden; background:#0d1117; color:white; font-family:"Segoe UI",sans-serif; }
  .navbar { display:flex; align-items:center; justify-content:space-between; background:linear-gradient(90deg,#00ff95,#0077ff); padding:10px 20px; }
  .navbar-left { display:flex; align-items:center; }
  .navbar img { height:40px; margin-right:10px; }
  .navbar h1 { font-size:22px; margin:0; }
  .delete-menu { display:flex; gap:10px; }
  .delete-menu button { background:#111; color:white; border:1px solid #00ff95; border-radius:6px; padding:5px 10px; cursor:pointer; transition:0.2s; }
  .delete-menu button:hover { background:#00ff95; color:black; }
  canvas { display:block; background:#161b22; }

  /* --- NEW UI STYLES --- */
  /* Sidebar */
  #sidebar {
    position: fixed;
    top: 60px;
    right: -360px; /* hidden by default */
    width: 340px;
    height: calc(100% - 60px);
    background: linear-gradient(180deg, rgba(10,12,18,0.98), rgba(18,20,28,0.98));
    border-left: 1px solid rgba(255,255,255,0.03);
    padding: 14px;
    box-shadow: -30px 0 60px rgba(0,0,0,0.6);
    transition: right 0.34s cubic-bezier(.2,.8,.2,1);
    z-index: 200;
    overflow-y: auto;
    backdrop-filter: blur(6px);
  }
  #sidebar.open { right: 0; }

  .ui-section-title { font-weight:600; margin: 6px 0 10px 0; color: #dbefff; font-size:14px; }
  .tab-buttons { display:flex; gap:8px; margin-bottom:12px; }
  .tab-buttons button {
    flex:1;
    padding:8px;
    border-radius:8px;
    background: rgba(255,255,255,0.03);
    color: #cfefff;
    border: 1px solid rgba(255,255,255,0.04);
    cursor:pointer;
  }
  .tab-buttons button.active { background: rgba(0,255,255,0.08); border-color: rgba(0,255,255,0.18); color: #ffffff; }

  .tab-content { display:none; }
  .tab-content.active { display:block; }

  .object-item {
    display:flex;
    align-items:center;
    gap:10px;
    padding:10px;
    margin:8px 0;
    background: rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.03);
    border-radius:8px;
    cursor: grab;
    user-select: none;
  }
  .object-item:active { cursor: grabbing; }

  .prop-row { display:flex; justify-content:space-between; gap:8px; align-items:center; margin:8px 0; }
  .prop-row label { flex:1; font-size:13px; color:#d7eefe; }
  .prop-row input[type="number"], .prop-row input[type="text"] {
    width:100px;
    padding:6px;
    border-radius:6px;
    border:1px solid rgba(255,255,255,0.06);
    background: rgba(255,255,255,0.02);
    color: white;
  }
  .prop-row input[type="checkbox"] { transform:scale(1.2); }

  #apply-props {
    margin-top:10px;
    width:100%;
    padding:8px;
    border-radius:8px;
    border:none;
    background: linear-gradient(90deg,#00c9ff,#0077ff);
    color:#001;
    font-weight:700;
    cursor:pointer;
  }

  /* small helper: selection highlight overlay top-right */
  .ui-hint { position:fixed; right:360px; top:70px; color:rgba(200,220,255,0.65); font-size:12px; z-index:210; display:none; }
  .ui-hint.visible { display:block; }

  /* make sure canvas area still clickable for drag/drop */
  #world { touch-action: none; }

  /* menu button */
  #uiMenuBtn {
    background: rgba(0,0,0,0.12);
    border: 1px solid rgba(255,255,255,0.06);
    color: white;
    padding:6px 10px;
    border-radius:8px;
    cursor:pointer;
    margin-left:8px;
  }
</style>
</head>
<body>

<div class="navbar">
  <div class="navbar-left">
    <img src="Logo.png" alt="Logo">
    <h1>PlyGround Physics Engine</h1>
  </div>
  <div class="delete-menu">
    <button id="delLast">Delete Last</button>
    <button id="delAll">Delete All</button>
    <button id="delMode">Delete Mode: OFF</button>
    <!-- NEW UI TOGGLE BUTTON (added, doesn't remove anything) -->
    <button id="uiMenuBtn" title="Open UI">‚ò∞ UI</button>
  </div>
</div>

<canvas id="world"></canvas>

<!-- Sidebar UI (sliding from right) -->
<div id="sidebar" aria-hidden="true">
  <div class="tab-buttons">
    <button class="tab-btn active" data-tab="objects">Objects</button>
    <button class="tab-btn" data-tab="properties">Properties</button>
  </div>

  <div id="tab-objects" class="tab-content active">
    <div class="ui-section-title">Drag & Drop Objects</div>

    <div class="object-item" draggable="true" data-type="box">üì¶ Box</div>
    <div class="object-item" draggable="true" data-type="ball">‚ö™ Ball</div>
    <div class="object-item" draggable="true" data-type="triangle">üî∫ Triangle</div>
    <div class="object-item" draggable="true" data-type="rod">‚ñ¨ Rod</div>
    <div class="object-item" draggable="true" data-type="star">‚≠ê Star</div>
    <div class="object-item" draggable="true" data-type="hex">‚¨£ Hex</div>
    <div class="object-item" draggable="true" data-type="plank">ü™µ Plank</div>
    <div class="object-item" draggable="true" data-type="miniball">‚Ä¢ MiniBall</div>
    <div class="object-item" draggable="true" data-type="tnt">üí£ TNT</div>
    <div class="object-item" draggable="true" data-type="torch">üïØÔ∏è Torch</div>
    <div class="object-item" draggable="true" data-type="bluestone">üî∑ BlueStone</div>
    <div class="object-item" draggable="true" data-type="quartz">üíé Quartz</div>
    <div class="object-item" draggable="true" data-type="lamp">üí° Lamp</div>


    <div style="height:20px"></div>
    <div class="ui-section-title">Quick Tips</div>
    <div style="font-size:13px;color:#cde8ff;line-height:1.4">
      ‚Ä¢ Drag items onto the canvas to spawn.<br>
      ‚Ä¢ Double-click an object on the canvas to inspect its properties.<br>
      ‚Ä¢ Edit density/friction and press Apply to update live.<br>
      ‚Ä¢ Objects marked 'Burnable' will ignite from nearby fire.
    </div>
  </div>

  <div id="tab-properties" class="tab-content">
    <div class="ui-section-title">Selected Object</div>
    <div id="no-selection" style="color:#9fbfe6;font-size:13px">No object selected. Double-click an object on the canvas.</div>

    <div id="prop-panel" style="display:none">
      <div class="prop-row">
        <label>Label</label>
        <input id="prop-label" type="text" />
      </div>
      <div class="prop-row">
        <label>Density</label>
        <input id="prop-density" type="number" step="0.01" />
      </div>
      <div class="prop-row">
        <label>Friction</label>
        <input id="prop-friction" type="number" step="0.01" />
      </div>
      <div class="prop-row" style="justify-content:flex-start;">
        <label style="flex:0 0 auto;margin-right:6px">Burnable</label>
        <input id="prop-burn" type="checkbox" />
      </div>

      <button id="apply-props">Apply</button>
      <div style="height:12px"></div>
      <div style="font-size:12px;color:#cde8ff">Note: Some changes (like mass/density) may slightly alter current velocities.</div>
    </div>
  </div>
</div>

<div class="ui-hint" id="uiHint">Double-click object ‚Üí properties appear</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
const { Engine, Render, Runner, Bodies, World, Mouse, MouseConstraint, Events, Body, Vector } = Matter;

// --- Setup ---
const engine = Engine.create();
const world = engine.world;
const canvas = document.getElementById("world");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 60;

const render = Render.create({
  canvas,
  engine,
  options: {
    width: canvas.width,
    height: canvas.height,
    background: "#161b22",
    wireframes: false,
  },
});
Render.run(render);
Runner.run(Runner.create(), engine);

// --- Boundaries ---
const ground = Bodies.rectangle(canvas.width/2, canvas.height, canvas.width, 60, { isStatic: true, label: "Ground" });
const leftWall = Bodies.rectangle(0, canvas.height/2, 60, canvas.height, { isStatic: true, label: "Wall" });
const rightWall = Bodies.rectangle(canvas.width, canvas.height/2, 60, canvas.height, { isStatic: true, label: "Wall" });
World.add(world, [ground, leftWall, rightWall]);

// --- Track spawned bodies ---
let spawnedBodies = [];

// --- Spawn Functions (labels added) ---
function spawnBall(x, y) {
  const ball = Bodies.circle(x, y, 30, { restitution: 0.9, friction: 0.01, render: { fillStyle: "#00ccff" }, label: "Ball" });
  World.add(world, ball);
  spawnedBodies.push(ball);
}
function spawnBox(x, y) {
  const box = Bodies.rectangle(x, y, 60, 60, {
    restitution: 0.9,
    friction: 0.02,
    render: {
      sprite: {
        texture: "Box.png",
        xScale: 0.15,
        yScale: 0.15
      }
    },
    label: "Box"
  });
  World.add(world, box);
  spawnedBodies.push(box);
}
function spawnTriangle(x, y) {
  const tri = Bodies.polygon(x, y, 3, 50, { restitution: 0.9, render: { fillStyle: "#ff6699" }, label: "Triangle" });
  World.add(world, tri);
  spawnedBodies.push(tri);
}
function spawnRod(x, y) {
  const rod = Bodies.rectangle(x, y, 300, 35, { restitution: 0.9, friction: 0.02, density: 0.004, render: { fillStyle: "#88ff88" }, label: "Rod" });
  World.add(world, rod);
  spawnedBodies.push(rod);
}
function spawnStar(x, y) {
  const star = Bodies.polygon(x, y, 5, 40, { restitution: 0.8, render: { fillStyle: "#ff33cc" }, label: "Star" });
  World.add(world, star);
  spawnedBodies.push(star);
}
function spawnHex(x, y) {
  const hex = Bodies.polygon(x, y, 6, 50, { restitution: 0.8, render: { fillStyle: "#33ffcc" }, label: "Hex" });
  World.add(world, hex);
  spawnedBodies.push(hex);
}
function spawnPlank(x, y) {
  const plank = Bodies.rectangle(x, y, 400, 20, { restitution: 0.6, render: { fillStyle: "#ffaa33" }, label: "Plank" });
  World.add(world, plank);
  spawnedBodies.push(plank);
}
function spawnMiniBall(x, y) {
  const small = Bodies.circle(x, y, 15, { restitution: 1.0, friction: 0, render: { fillStyle: "#ffffff" }, label: "MiniBall" });
  World.add(world, small);
  spawnedBodies.push(small);
}
// --- üß± BlueStone ---
function spawnBlueStone(x, y) {
  const stone = Bodies.rectangle(x, y, 70, 70, {
    restitution: 0.3,
    friction: 0.9,
    density: 0.006,
    render: {
      sprite: {
        texture: "bluestone.png", // your BlueStone texture file
        xScale: 0.2,
        yScale: 0.2
      }
    },
    label: "BlueStone",
  });
  World.add(world, stone);
  spawnedBodies.push(stone);
}

// --- üíé Quartz ---
function spawnQuartz(x, y) {
  const quartz = Bodies.polygon(x, y, 6, 40, {
    restitution: 0.4,
    friction: 0.7,
    density: 0.004,
    render: {
      sprite: {
        texture: "quartz.png", // your Quartz texture file
        xScale: 0.15,
        yScale: 0.15
      }
    },
    label: "Quartz",
  });
  World.add(world, quartz);
  spawnedBodies.push(quartz);
}

// --- üí° Lamp ---
function spawnLamp(x, y) {
  const lamp = Bodies.rectangle(x, y, 60, 100, {
    restitution: 0.3,
    friction: 0.6,
    density: 0.003,
    render: {
      sprite: {
        texture: "lamp.png", // your Lamp image file
        xScale: 0.2,
        yScale: 0.2
      }
    },
    label: "Lamp",
  });
  World.add(world, lamp);
  spawnedBodies.push(lamp);

  // ‚ú® Soft light effect around Lamp
  setInterval(() => {
    if (!spawnedBodies.includes(lamp)) return;
    const topX = lamp.position.x;
    const topY = lamp.position.y - 50;
    createFireCluster(topX, topY, 0.6);
  }, 500);
}

// --- Mouse Control ---
const mouse = Mouse.create(render.canvas);
const mouseConstraint = MouseConstraint.create(engine, { mouse, constraint: { stiffness: 0.2, render: { visible: false } } });
World.add(world, mouseConstraint);
render.mouse = mouse;

let dragStart = null;
let dragBody = null;
Events.on(mouseConstraint, "startdrag", e => { dragBody = e.body; dragStart = { ...mouse.position }; });
Events.on(mouseConstraint, "enddrag", e => {
  if (dragBody) {
    const dragEnd = { ...mouse.position };
    const dir = Vector.sub(dragEnd, dragStart);
    const distance = Vector.magnitude(dir);
    if (distance > 10) {
      const normalized = Vector.normalise(dir);
      const power = Math.min(distance * 0.0004, 0.02);
      const force = Vector.mult(normalized, power);
      Body.applyForce(dragBody, dragBody.position, force);
    }
  }
  dragBody = null;
  dragStart = null;
});

// --- Spawn Hotkeys ---
document.addEventListener("keydown", e => {
  const k = e.key.toLowerCase();
  if (k === "1") spawnBall(mouse.position.x, mouse.position.y);
  if (k === "2") spawnBox(mouse.position.x, mouse.position.y);
  if (k === "3") spawnTriangle(mouse.position.x, mouse.position.y);
  if (k === "4") spawnRod(mouse.position.x, mouse.position.y);
  if (k === "5") spawnStar(mouse.position.x, mouse.position.y);
  if (k === "6") spawnHex(mouse.position.x, mouse.position.y);
  if (k === "7") spawnPlank(mouse.position.x, mouse.position.y);
  if (k === "8") spawnMiniBall(mouse.position.x, mouse.position.y);
});

// --- Delete Menu ---
const delLastBtn = document.getElementById("delLast");
const delAllBtn = document.getElementById("delAll");
const delModeBtn = document.getElementById("delMode");
let deleteMode = false;
delLastBtn.onclick = () => { const last = spawnedBodies.pop(); if (last) World.remove(world, last); };
delAllBtn.onclick = () => window.location.reload();
delModeBtn.onclick = () => { deleteMode = !deleteMode; delModeBtn.textContent = `Delete Mode: ${deleteMode ? "ON" : "OFF"}`; };
Events.on(mouseConstraint, "mousedown", e => {
  if (deleteMode && e.body && !e.body.isStatic) {
    World.remove(world, e.body);
    spawnedBodies = spawnedBodies.filter(b => b !== e.body);
  }
});

// --- üî• FIRE SYSTEM (with soft glow) ---
const fires = [];
const burningBodies = new Set();

function createFireCluster(x, y, sizeFactor = 1) {
  for (let i = 0; i < 8; i++) {
    fires.push({
      x: x + (Math.random() - 0.5) * 40,
      y: y + (Math.random() - 0.5) * 40,
      size: (Math.random() * 10 + 15) * sizeFactor,
      life: 1,
      rise: 1.8 + Math.random() * 1.8,
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.25,
    });
  }
}

(function animateFire() {
  requestAnimationFrame(animateFire);
  const ctx = render.context;
  if (!ctx) return;
  ctx.save();
  ctx.globalCompositeOperation = "lighter";

  for (let i = fires.length - 1; i >= 0; i--) {
    const f = fires[i];
    f.y -= f.rise;
    f.rotation += f.rotSpeed;
    f.life -= 0.014;
    const alpha = Math.max(f.life, 0);

    // --- üü† Draw flame particle ---
    const grad = ctx.createLinearGradient(f.x, f.y + f.size, f.x, f.y - f.size);
    grad.addColorStop(0, "rgba(255,0,0,0.9)");
    grad.addColorStop(1, "rgba(125,125,0,0.1)");
    ctx.translate(f.x, f.y);
    ctx.rotate(f.rotation);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = grad;
    ctx.fillRect(-f.size / 2, -f.size / 2, f.size, f.size);
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // cleanup dead fire particles
    if (f.life <= 0) fires.splice(i, 1);
  }

  ctx.restore();
})();
// Track mouse position
let mouseX = 0, mouseY = 0;

window.addEventListener("mousemove", (e) => {
  const rect = render.canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
});

// Listen for 'S' key press
window.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === 's') {
    createFireCluster(mouseX, mouseY, 1); // sizeFactor = 1
  }
});


// --- IGNITE & ASH SYSTEM ---
function igniteNearbyBodies() {
  for (const body of spawnedBodies) {
    if (body.isStatic || !body.position) continue;
    if (burningBodies.has(body)) continue;
    if (!body.burnable && body.label !== "Box" && body.label !== "Plank") continue;


    for (const fire of fires) {
      const dx = fire.x - body.position.x;
      const dy = fire.y - body.position.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 60) igniteBody(body);
    }
  }
}
setInterval(igniteNearbyBodies, 100);


canvas.addEventListener("dblclick", (e) => {
  const mousePos = { x: e.clientX, y: e.clientY };
  const found = Matter.Query.point(spawnedBodies, mousePos);
  if (found.length > 0) {
    selectedBody = found[0];
    showProperties(selectedBody);
  }
});

function showProperties(body) {
  document.getElementById("no-selection").style.display = "none";
  document.getElementById("prop-panel").style.display = "block";
  document.getElementById("prop-label").value = body.label || "";
  document.getElementById("prop-density").value = body.density || 0;
  document.getElementById("prop-friction").value = body.friction || 0;
  document.getElementById("prop-burn").checked = !!body.burnable;
}

// Apply property changes
document.getElementById("apply-props").addEventListener("click", () => {
  if (!selectedBody) return;
  selectedBody.label = document.getElementById("prop-label").value;
  selectedBody.friction = parseFloat(document.getElementById("prop-friction").value) || selectedBody.friction;
  selectedBody.burnable = document.getElementById("prop-burn").checked;
  Matter.Body.setDensity(selectedBody, parseFloat(document.getElementById("prop-density").value) || selectedBody.density);
});


function igniteBody(body) {
  if (burningBodies.has(body)) return;
  burningBodies.add(body);

  const burnInterval = setInterval(() => {
    if (!spawnedBodies.includes(body)) {
      clearInterval(burnInterval);
      burningBodies.delete(body);
      return;
    }
    createFireCluster(body.position.x, body.position.y - 30, 0.8);
  }, 200);

  setTimeout(() => {
    clearInterval(burnInterval);
    burningBodies.delete(body);
    turnToAsh(body);
  }, 10000);
}

function turnToAsh(body) {
  if (!spawnedBodies.includes(body)) return;

  const width = body.bounds.max.x - body.bounds.min.x;
  const height = body.bounds.max.y - body.bounds.min.y;

  const ash = Bodies.rectangle(
    body.position.x,
    body.position.y,
    width,
    height,
    {
      restitution: 0.2,
      friction: 0.8,
      density: 0.0005,
      label: "Ash",
      render: {
        sprite: {
          texture: "Ash.png",  // üíÄ your ash texture file
          xScale: width / 512,         // adjust depending on texture resolution
          yScale: height / 512
        }
      }
    }
  );

  World.remove(world, body);
  World.add(world, ash);
  spawnedBodies = spawnedBodies.filter(b => b !== body);
  spawnedBodies.push(ash);
}

Events.on(engine, "collisionStart", e => {
  for (const pair of e.pairs) {
    [pair.bodyA, pair.bodyB].forEach(b => {
      if (b.label === "Ash" && pair.collision.depth > 5) crumbleAsh(b);
    });
  }
});

function crumbleAsh(ash) {
  if (!spawnedBodies.includes(ash)) return;
  const x = ash.position.x, y = ash.position.y;
  World.remove(world, ash);
  spawnedBodies = spawnedBodies.filter(b => b !== ash);

  for (let i = 0; i < 8; i++) {
    const size = 8 + Math.random() * 4;
    const frag = Bodies.rectangle(
      x + (Math.random() - 0.5) * 40,
      y + (Math.random() - 0.5) * 20,
      size,
      size,
      {
        restitution: 0.6,
        friction: 0.9,
        density: 0.0003,
        render: {
          fillStyle: "#555",
          opacity: 1, // start fully visible
        },
        label: "AshFragment",
      }
    );

    // Apply a random flying force
    const forceMagnitude = 0.0005 + Math.random() * 0.0001;
    const angle = Math.random() * Math.PI * 2; // random direction
    Body.applyForce(frag, frag.position, {
      x: Math.cos(angle) * forceMagnitude,
      y: Math.sin(angle) * forceMagnitude,
    });

    World.add(world, frag);
    spawnedBodies.push(frag);

    // Gradually fade out and remove after 10s
    const fadeDuration = 10000; // 10 seconds
    const fadeStep = 100; // update every 0.1s
    let elapsed = 0;

    const fadeInterval = setInterval(() => {
      elapsed += fadeStep;
      const alpha = Math.max(1 - elapsed / fadeDuration, 0);
      frag.render.opacity = alpha;

      if (alpha <= 0) {
        clearInterval(fadeInterval);
        World.remove(world, frag);
        spawnedBodies = spawnedBodies.filter(b => b !== frag);
      }
    }, fadeStep);
  }
}


// --- üî¶ TORCH SYSTEM (Dynamic, Textured Torch with Moving Flame) ---
const torches = [];

function spawnTorch(x, y) {
  const torch = Bodies.rectangle(x, y, 20, 120, {
    restitution: 0.3,
    friction: 0.6,
    density: 0.002,
    render: {
      sprite: {
        texture: "torch.png", // ü™µ Your torch image file
        xScale: 0.25,          // adjust these two if needed
        yScale: 0.25,
      },
    },
    label: "Torch",
  });

  World.add(world, torch);
  spawnedBodies.push(torch);
  torches.push(torch);



  // üî• Fire that follows the top dynamically
  const fireInterval = setInterval(() => {
    if (!spawnedBodies.includes(torch)) {
      clearInterval(fireInterval);
      return;
    }

    // Dynamic top position using rotation
    const topOffset = Vector.rotate({ x: 0, y: -60 }, torch.angle);
    const topX = torch.position.x + topOffset.x;
    const topY = torch.position.y + topOffset.y;

    createFireCluster(topX, topY, 1.2);
  }, 250);
}

// üïØÔ∏è Press "T" to spawn torch
document.addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "t") {
    const { x, y } = mouse.position;
    spawnTorch(x, y);
  }
});
// --- TNT ARRAY ---
let spawnedTNTs = [];

// --- SPAWN TNT (Press X) ---
document.addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "x") {
    const tnt = Bodies.rectangle(mouse.position.x, mouse.position.y, 45, 45, {
      label: "TNT",
      restitution: 0.4,
      friction: 0.6,
      render: {
        fillStyle: "#cc0000",
        strokeStyle: "#ffffff",
        lineWidth: 2
      }
    });
    World.add(world, tnt);
    spawnedBodies.push(tnt);
    spawnedTNTs.push(tnt);
  }
});

// --- IGNITE TNT (Press E) ---
document.addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "e") {
    if (spawnedTNTs.length === 0) return;

    const nearestTNT = spawnedTNTs[spawnedTNTs.length - 1];

    // üî• Visual fuse flame
    createFireCluster(nearestTNT.position.x, nearestTNT.position.y, 1.4);

    // üß® Text hint
    const ctx = render.context;
    ctx.font = "bold 18px Arial";
    ctx.fillStyle = "white";
    ctx.fillText("üí• FUSE LIT! GET BACK!", nearestTNT.position.x - 60, nearestTNT.position.y - 60);

    // Delay for fuse (2.5s)
    setTimeout(() => explodeTNT(nearestTNT), 2500);
  }
});


// --- EXPLOSION FUNCTION ---
function explodeTNT(tnt) {
  const x = tnt.position.x;
  const y = tnt.position.y;
  const radius = 300; // Bigger blast radius

  // üí• Stronger visual shockwave
  for (let i = 0; i < 25; i++) {
    createFireCluster(x, y, 1.8);
  }

  // üîä Add visible expanding ring (shockwave)
  let waveLife = 1;
  const wave = { x, y, r: 0, life: waveLife };
  const ctx = render.context;

  function animateWave() {
    if (wave.life <= 0) return;
    requestAnimationFrame(animateWave);
    wave.r += 25; // expand speed
    wave.life -= 0.03;

    ctx.save();
    ctx.beginPath();
    ctx.arc(wave.x, wave.y, wave.r, 0, 2 * Math.PI);
    ctx.lineWidth = 6;
    ctx.strokeStyle = `rgba(255,255,255,${wave.life})`;
    ctx.stroke();
    ctx.restore();
  }
  animateWave();

  // üí® Apply much stronger blast force
  for (const body of spawnedBodies) {
    if (body === tnt) continue;
    const dx = body.position.x - x;
    const dy = body.position.y - y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < radius) {
      // Stronger and more consistent push
      const forceMag = Math.max(0, 0.55 * (1 - dist / radius));
      const angle = Math.atan2(dy, dx);
      const force = {
        x: Math.cos(angle) * forceMag,
        y: Math.sin(angle) * forceMag - 0.02 // adds upward lift
      };
      Body.applyForce(body, body.position, force);
    }
  }


  // üî• Ignite nearby boxes/planks only
  for (const body of spawnedBodies) {
    const dx = body.position.x - x;
    const dy = body.position.y - y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 220 && (body.label === "Box" || body.label === "Plank")) {
      igniteBody(body);
    }
  }

  // üß® Remove TNT body
  World.remove(world, tnt);
  spawnedBodies = spawnedBodies.filter(b => b !== tnt);
  spawnedTNTs = spawnedTNTs.filter(b => b !== tnt);
}
// --- ü™¢ Real Rigid Rope Physics (no stretch, soft bend, realistic look) ---
const { Constraint, Query } = Matter;
let ropeMode = false;
let ropeStart = null;
let ropes = [];
let highlightBody = null;

document.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();

  if (key === "q") {
    ropeMode = !ropeMode;
    ropeStart = null;
    highlightBody = null;
    console.log(`ü™¢ Rope Mode: ${ropeMode ? "ON" : "OFF"}`);
  }

  // üóë Remove nearest rope
  if (key === "r") {
    if (ropes.length > 0) {
      const mousePos = mouse.position;
      let nearestRope = null;
      let nearestDist = Infinity;

      for (const rope of ropes) {
        for (const seg of rope.segments) {
          const dx = seg.position.x - mousePos.x;
          const dy = seg.position.y - mousePos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestRope = rope;
          }
        }
      }

      if (nearestRope && nearestDist < 100) removeRope(nearestRope);
      else removeRope(ropes[ropes.length - 1]);
      console.log("‚ùå Rope removed.");
    }
  }
});

function removeRope(rope) {
  for (const seg of rope.segments) World.remove(world, seg);
  for (const c of rope.constraints) World.remove(world, c);
  ropes = ropes.filter(r => r !== rope);
}

// --- Rope creation ---
Events.on(mouseConstraint, "mousedown", () => {
  if (!ropeMode) return;
  const mousePos = mouse.position;
  const found = Query.point(spawnedBodies, mousePos);
  if (found.length > 0) {
    const body = found[0];
    if (!ropeStart) {
      ropeStart = body;
      console.log("üîπ First body selected for rope.");
    } else if (body !== ropeStart) {
      createRealRope(ropeStart, body);
      ropeStart = null;
      console.log("ü™¢ Rope created.");
    }
  }
});

// --- Highlight body under mouse ---
Events.on(render, "beforeRender", () => {
  if (!ropeMode) {
    highlightBody = null;
    return;
  }
  const found = Query.point(spawnedBodies, mouse.position);
  highlightBody = found.length > 0 ? found[0] : null;
});

// --- Create Rigid Rope (zero stretch, soft bend) ---
function createRealRope(bodyA, bodyB, segments = 15) {
  const ropeSegments = [];
  const constraints = [];

  const start = bodyA.position;
  const end = bodyB.position;
  const dx = (end.x - start.x) / (segments + 1);
  const dy = (end.y - start.y) / (segments + 1);
  const segmentLength = Math.sqrt(dx * dx + dy * dy);

  // üß© Create rigid rope links
  for (let i = 0; i < segments; i++) {
    const link = Bodies.circle(start.x + dx * (i + 1), start.y + dy * (i + 1), 3, {
      friction: 0.8,
      restitution: 0,
      mass: 0.1,
      density: 0.005,
      collisionFilter: { group: -1 },
      render: { fillStyle: "#ffaa00" }
    });
    ropeSegments.push(link);
    World.add(world, link);
  }

  // üîó Create very stiff constraints (virtually rigid)
  const makeConstraint = (A, B) => Constraint.create({
    bodyA: A,
    bodyB: B,
    length: segmentLength,
    stiffness: 1,      // <--- full stiffness (no stretch)
    damping: 0.2,      // <--- removes vibration
    render: { visible: false }
  });

  // connect first link to bodyA
  constraints.push(makeConstraint(bodyA, ropeSegments[0]));

  // connect middle links
  for (let i = 0; i < ropeSegments.length - 1; i++) {
    constraints.push(makeConstraint(ropeSegments[i], ropeSegments[i + 1]));
  }

  // connect last link to bodyB
  constraints.push(makeConstraint(ropeSegments[ropeSegments.length - 1], bodyB));

  // add to world
  for (const c of constraints) World.add(world, c);

  ropes.push({ bodyA, bodyB, segments: ropeSegments, constraints });
}


// --- Rope Auto-Break System ---
Events.on(engine, "afterUpdate", () => {
  for (let i = ropes.length - 1; i >= 0; i--) {
    const rope = ropes[i];
    if (!world.bodies.includes(rope.bodyA) || !world.bodies.includes(rope.bodyB)) {
      removeRope(rope);
      console.log("üí• Rope broke: connected body removed.");
    }
  }
});

// --- Render rope (fiber texture + bend + highlight) ---
Events.on(render, "afterRender", () => {
  const ctx = render.context;
  ctx.save();

  for (const rope of ropes) {
    const pts = [rope.bodyA.position, ...rope.segments.map(s => s.position), rope.bodyB.position];
    if (pts.length < 2) continue;

    // üé® Rope gradient (brown-gold fiber)
    const grad = ctx.createLinearGradient(pts[0].x, pts[0].y, pts[pts.length - 1].x, pts[pts.length - 1].y);
    grad.addColorStop(0, "#b8860b");
    grad.addColorStop(0.5, "#d2b48c");
    grad.addColorStop(1, "#b8860b");

    ctx.strokeStyle = grad;
    ctx.lineWidth = 4;
    ctx.shadowColor = "#d2b48c";
    ctx.shadowBlur = 8;

    // ü™∂ Smooth natural rope bend (quadratic curve)
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length - 1; i++) {
      const xc = (pts[i].x + pts[i + 1].x) / 2;
      const yc = (pts[i].y + pts[i + 1].y) / 2;
      ctx.quadraticCurveTo(pts[i].x, pts[i].y, xc, yc);
    }
    ctx.lineTo(pts[pts.length - 1].x, pts[pts.length - 1].y);
    ctx.stroke();
  }

  // ‚úÖ Keep your green/blue selection outline
  if (highlightBody) {
    const b = highlightBody.bounds;
    ctx.strokeStyle = ropeStart ? "#00ffff" : "#00ff00";
    ctx.lineWidth = 2;
    ctx.shadowBlur = 8;
    ctx.shadowColor = ctx.strokeStyle;
    ctx.strokeRect(b.min.x - 2, b.min.y - 2, b.max.x - b.min.x + 4, b.max.y - b.min.y + 4);
  }

  ctx.restore();
});



// --- üî© SCREW SYSTEM (With Texture + Removal) ---
let screwMode = false;
let screws = []; // store screws with linked bodies

document.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();

  // Toggle screw mode
  if (key === "z") {
    screwMode = !screwMode;
    console.log(`üî© Screw Mode: ${screwMode ? "ON" : "OFF"}`);

    // When pressing Z while dragging a body
    if (screwMode && mouseConstraint.body && !mouseConstraint.body.isStatic) {
      const target = mouseConstraint.body;
      const pos = { x: mouse.position.x, y: mouse.position.y };

      // Create screw visual
      const screw = Bodies.circle(pos.x, pos.y, 15, {
        isStatic: true,
        render: {
          sprite: {
            texture: "Screw.png", // üß∑ your screw texture file
            xScale: 0.1,
            yScale: 0.1,
          }
        },
        label: "Screw"
      });
      World.add(world, screw);

      // Turn body static
      Body.setStatic(target, true);
      console.log("üß± Object screwed and fixed in place.");

      screws.push({ screw, target });
      screwMode = false; // auto turn off mode after placing
    }
  }

  // Remove screw (press C)
  if (key === "c") {
    const mousePos = mouse.position;
    for (let i = screws.length - 1; i >= 0; i--) {
      const { screw, target } = screws[i];
      const dx = mousePos.x - screw.position.x;
      const dy = mousePos.y - screw.position.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // If mouse near screw, unscrew it
      if (dist < 40) {
        World.remove(world, screw);
        Body.setStatic(target, false);
        console.log("üîì Screw removed ‚Äî object is now dynamic again!");
        screws.splice(i, 1);

        // üîÑ Small unscrew animation effect
        const ctx = render.context;
        ctx.save();
        ctx.strokeStyle = "#ffcc00";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(mousePos.x, mousePos.y, 20, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.restore();
      }
    }
  }
});

// Optional visual marker glow (so you can see all screws)
Events.on(render, "afterRender", () => {
  const ctx = render.context;
  ctx.save();
  for (const { screw } of screws) {
    ctx.beginPath();
    ctx.arc(screw.position.x, screw.position.y, 16, 0, 2 * Math.PI);
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,255,0,0.4)";
    ctx.stroke();
  }
  ctx.restore();
});

/* =========================
   NEW UI FUNCTIONALITY CODE
   (ADDED ‚Äî does not remove old code)
   ========================= */

// Sidebar toggle
const uiMenuBtn = document.getElementById('uiMenuBtn');
const sidebar = document.getElementById('sidebar');
const uiHint = document.getElementById('uiHint');
uiMenuBtn.addEventListener('click', () => {
  sidebar.classList.toggle('open');
  sidebar.setAttribute('aria-hidden', !sidebar.classList.contains('open'));
  uiHint.classList.toggle('visible', sidebar.classList.contains('open'));
});

// Tabs
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const tab = btn.dataset.tab;
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    document.getElementById('tab-' + tab).classList.add('active');
  });
});

// Drag setup for object items
document.querySelectorAll('.object-item').forEach(item => {
  item.addEventListener('dragstart', (ev) => {
    ev.dataTransfer.setData('text/plain', item.dataset.type);
    // show ghost image (optional)
    try {
      const crt = item.cloneNode(true);
      crt.style.position = "absolute";
      crt.style.top = "-1000px";
      crt.style.left = "-1000px";
      document.body.appendChild(crt);
      ev.dataTransfer.setDragImage(crt, 10, 10);
      setTimeout(()=> crt.remove(), 0);
    } catch(e){/* ignore */ }
  });
});

// Drop onto canvas
canvas.addEventListener('dragover', ev => ev.preventDefault());
canvas.addEventListener('drop', ev => {
  ev.preventDefault();
  const type = ev.dataTransfer.getData('text/plain');
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  spawnFromType(type, x, y);
});

// helper spawn that uses your existing spawn functions (and TNT/torch special cases)
function spawnFromType(type, x, y) {
  switch(type) {
    case 'box': spawnBox(x, y); break;
    case 'ball': spawnBall(x, y); break;
    case 'triangle': spawnTriangle(x, y); break;
    case 'rod': spawnRod(x, y); break;
    case 'star': spawnStar(x, y); break;
    case 'hex': spawnHex(x, y); break;
    case 'plank': spawnPlank(x, y); break;
    case 'miniball': spawnMiniBall(x, y); break;
    case 'tnt':
      {
        const tnt = Bodies.rectangle(x, y, 45, 45, {
          label: "TNT",
          restitution: 0.4,
          friction: 0.6,
          render: {
            fillStyle: "#cc0000",
            strokeStyle: "#ffffff",
            lineWidth: 2
          }
        });
        World.add(world, tnt);
        spawnedBodies.push(tnt);
        spawnedTNTs.push(tnt);
      }
      break;
    case 'torch':
      spawnTorch(x, y);
      break;
    default:
      spawnBall(x, y);
  }
}

// Double-click selection and properties
let selectedBody = null;
let previousSelected = null;

function clearSelectionStyle(body) {
  if (!body || !body.render) return;
  // remove custom stroke we might have set
  if (body.render.strokeStyle) {
    delete body.render.strokeStyle;
  }
  if (body.render.lineWidth) {
    delete body.render.lineWidth;
  }
}

render.canvas.addEventListener('dblclick', (ev) => {
  const rect = render.canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;

  const found = Query.point(spawnedBodies, { x, y }) || [];
  if (found.length > 0) {
    if (previousSelected && previousSelected !== found[0]) {
      clearSelectionStyle(previousSelected);
    }
    selectedBody = found[0];
    previousSelected = selectedBody;

    // add glow style
    if (!selectedBody.render) selectedBody.render = {};
    selectedBody.render.strokeStyle = 'cyan';
    selectedBody.render.lineWidth = 4;

    showProperties(selectedBody);
  } else {
    // clicked empty space -> clear selection
    if (previousSelected) {
      clearSelectionStyle(previousSelected);
      previousSelected = null;
    }
    selectedBody = null;
    hideProperties();
  }
});

function showProperties(body) {
  document.querySelector('[data-tab="properties"]').click();
  document.getElementById('no-selection').style.display = 'none';
  document.getElementById('prop-panel').style.display = 'block';

  // fill values (guard undefineds)
  document.getElementById('prop-label').value = body.label || '';
  document.getElementById('prop-density').value = (typeof body.density === 'number') ? body.density.toFixed(3) : (body.mass ? (body.mass).toFixed(3) : '0.001');
  document.getElementById('prop-friction').value = (typeof body.friction === 'number') ? body.friction.toFixed(3) : '0.1';
  document.getElementById('prop-burn').checked = !!body.isBurnable;
  sidebar.classList.add('open');
  sidebar.setAttribute('aria-hidden', 'false');
  uiHint.classList.add('visible');
}

// hide properties panel
function hideProperties() {
  document.getElementById('no-selection').style.display = 'block';
  document.getElementById('prop-panel').style.display = 'none';
}

// apply properties live

// --- DELETE SELECTED OBJECT BUTTON ---
// Create the button dynamically (in case HTML didn't include it)
const deleteBtn = document.createElement("button");
deleteBtn.id = "delete-object";
deleteBtn.textContent = "DELETE";
Object.assign(deleteBtn.style, {
  marginTop: "10px",
  width: "100%",
  padding: "8px",
  borderRadius: "8px",
  border: "none",
  background: "linear-gradient(90deg,#ff3b3b,#cc0000)",
  color: "#fff",
  fontWeight: "700",
  cursor: "pointer",
  transition: "0.3s",
  letterSpacing: "1px"
});

// Add hover alert animation
deleteBtn.addEventListener("mouseenter", () => {
  deleteBtn.style.filter = "brightness(1.2)";
  deleteBtn.style.transform = "scale(1.05)";
});
deleteBtn.addEventListener("mouseleave", () => {
  deleteBtn.style.filter = "none";
  deleteBtn.style.transform = "scale(1)";
});

// Append below Apply button inside the properties panel
document.getElementById("prop-panel").appendChild(deleteBtn);

// --- Delete object logic ---
deleteBtn.addEventListener("click", () => {
  if (!selectedBody) return;
  const name = selectedBody.label || "this object";
  if (confirm(`‚ö†Ô∏è Delete "${name}" permanently?`)) {
    World.remove(world, selectedBody);
    spawnedBodies = spawnedBodies.filter(b => b !== selectedBody);
    if (typeof spawnedTNTs !== "undefined")
      spawnedTNTs = spawnedTNTs.filter(b => b !== selectedBody);

    selectedBody = null;
    hideProperties();
  }
});

document.getElementById('apply-props').addEventListener('click', () => {
  if (!selectedBody) return;
  // label
  selectedBody.label = document.getElementById('prop-label').value || selectedBody.label;

  // density
  const d = parseFloat(document.getElementById('prop-density').value);
  if (!isNaN(d) && d > 0) {
    // Body.setDensity exists ‚Äî it updates mass based on area.
    Body.setDensity(selectedBody, d);
    // keep density property for reading later
    selectedBody.density = d;
  }

  // friction
  const f = parseFloat(document.getElementById('prop-friction').value);
  if (!isNaN(f)) {
    selectedBody.friction = f;
  }

  // burnable flag (used by your ignite logic: you can check isBurnable or override)
  selectedBody.isBurnable = !!document.getElementById('prop-burn').checked;

  // visual feedback (tiny pulse)
  const ctx = render.context;
  ctx.save();
  ctx.beginPath();
  ctx.arc(selectedBody.position.x, selectedBody.position.y, 28, 0, 2 * Math.PI);
  ctx.lineWidth = 3;
  ctx.strokeStyle = 'rgba(0,255,255,0.6)';
  ctx.stroke();
  ctx.restore();

  // re-hide panel if you like, but keep it visible for further edits
});

// window resize: keep canvas sized
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - 60;
  render.options.width = canvas.width;
  render.options.height = canvas.height;
  Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: canvas.width, y: canvas.height } });
});

// close sidebar if user clicks outside it
document.addEventListener('click', (ev) => {
  const target = ev.target;
  if (!sidebar.contains(target) && !uiMenuBtn.contains(target) && sidebar.classList.contains('open')) {
    sidebar.classList.remove('open');
    sidebar.setAttribute('aria-hidden', 'true');
    uiHint.classList.remove('visible');
  }
});

// Prevent UI interfering with Matter mouse events when dragging from sidebar: small timeout to clear mouse state
document.querySelectorAll('.object-item').forEach(it => {
  it.addEventListener('dragend', () => {
    // tiny break to avoid accidental matter drag
    setTimeout(() => {
      mouseConstraint.body = null;
    }, 10);
  });
});

/* End of UI additions */

</script>
</body>
</html>
